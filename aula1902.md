# ğŸ“š Hierarquia de Classes

A **Hierarquia de Classes** (ou **Hierarquia de Chomsky**) Ã© uma classificaÃ§Ã£o das linguagens formais baseada no seu nÃ­vel de complexidade e no poder computacional necessÃ¡rio para reconhecÃª-las.

Ela divide as linguagens em quatro nÃ­veis, do mais simples ao mais poderoso, considerando o tipo de gramÃ¡tica que as gera e o modelo de autÃ´mato capaz de reconhecÃª-las.

## ğŸ”¹ Tipo 3 â€” Linguagens Regulares
- SÃ£o as mais simples.
- Descritas por **GramÃ¡ticas Regulares**.
- Reconhecidas por **AutÃ´matos Finitos (AFD e AFN)**.
- Representadas por **ExpressÃµes Regulares**.
- NÃ£o possuem memÃ³ria alÃ©m dos estados.

## ğŸ”¹ Tipo 2 â€” Linguagens Livres de Contexto
- Mais poderosas que as regulares.
- Descritas por **GramÃ¡ticas Livres de Contexto (GLC)**.
- Reconhecidas por **AutÃ´matos com Pilha (PDA)**.
- Possuem memÃ³ria auxiliar (pilha).

## ğŸ”¹ Tipo 1 â€” Linguagens SensÃ­veis ao Contexto
- Mais gerais que as livres de contexto.
- Descritas por **GramÃ¡ticas SensÃ­veis ao Contexto**.
- Reconhecidas por **MÃ¡quinas Linearmente Limitadas (LBA)**.
- A produÃ§Ã£o depende do contexto da variÃ¡vel.

## ğŸ”¹ Tipo 0 â€” Linguagens I
- SÃ£o as mais gerais e poderosas.
- Descritas por **GramÃ¡ticas Irrestritas**.
- Reconhecidas por **MÃ¡quinas de Turing**.
- NÃ£o possuem restriÃ§Ãµes nas regras de produÃ§Ã£o.

---

### ğŸ“Œ Resumo da Hierarquia (do menor para o maior poder)

Regular âŠ‚ Livre de Contexto âŠ‚ SensÃ­vel ao Contexto âŠ‚ Irrestrita
---
# ğŸ’» Linguagens LÃ©xica, SintÃ¡tica e SemÃ¢ntica

No estudo de **Linguagens Formais e AutÃ´matos**, todo programa passa por trÃªs nÃ­veis fundamentais de anÃ¡lise: **lÃ©xico**, **sintÃ¡tico** e **semÃ¢ntico**. Essas etapas explicam como o compilador entende o cÃ³digo escrito pelo programador.

---

## ğŸ”¹ AnÃ¡lise LÃ©xica

Ã‰ a primeira etapa. ResponsÃ¡vel por transformar o cÃ³digo-fonte em **tokens** (unidades bÃ¡sicas de significado).

### Exemplos de tokens:
- Palavras-chave â†’ `if`, `while`, `int`
- Identificadores â†’ `x`, `contador`
- Operadores â†’ `+`, `-`, `=`
- NÃºmeros â†’ `10`, `3.14`
- SÃ­mbolos â†’ `;`, `{`, `}`

ğŸ“Œ Base teÃ³rica: **Linguagens Regulares**  
ğŸ“Œ Utiliza: **ExpressÃµes Regulares e AutÃ´matos Finitos**

### Exemplo:
CÃ³digo: `int x = 10;`  
Tokens gerados: `int | x | = | 10 | ;`

---

## ğŸ”¹ AnÃ¡lise SintÃ¡tica

Ã‰ a segunda etapa. Verifica se a sequÃªncia de tokens estÃ¡ organizada de acordo com a **gramÃ¡tica da linguagem**.

ğŸ“Œ Base teÃ³rica: **Linguagens Livres de Contexto**  
ğŸ“Œ Utiliza: **GramÃ¡ticas Livres de Contexto (GLC)**  
ğŸ“Œ ConstrÃ³i: **Ãrvore SintÃ¡tica (Parse Tree)**

### Exemplo de erro sintÃ¡tico:
CÃ³digo: `int = x 10;`  
Os tokens sÃ£o vÃ¡lidos, mas a estrutura estÃ¡ incorreta.

---

## ğŸ”¹ AnÃ¡lise SemÃ¢ntica

Ã‰ a terceira etapa. Verifica o **significado do programa**, garantindo que tudo faz sentido logicamente.

Confere:
- Compatibilidade de tipos  
- VariÃ¡veis declaradas antes do uso  
- Escopo correto  
- CoerÃªncia das operaÃ§Ãµes  

### Exemplo de erro semÃ¢ntico:
CÃ³digo: `int x = "texto";`  
A estrutura estÃ¡ correta, mas o tipo Ã© incompatÃ­vel.

---

## ğŸ“Œ Resumo Final

- **LÃ©xico** â†’ Divide o cÃ³digo em tokens  
- **SintÃ¡tico** â†’ Verifica a estrutura gramatical  
- **SemÃ¢ntico** â†’ Verifica o significado e as regras da linguagem  

Essas trÃªs etapas sÃ£o essenciais para o funcionamento de compiladores e para a compreensÃ£o correta das linguagens de programaÃ§Ã£o.
